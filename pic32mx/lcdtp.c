
/*
	Smallest touchpanel UI https://github.com/paijp/smallest-touchpanel-ui

	Copyright (c) 2022-2024 paijp

	This software is released under the Apache 2.0 license.
	http://www.apache.org/licenses/
*/

#include	"xc.h"
#include	"lcdtp.h"

#pragma config  PMDL1WAY=OFF, IOL1WAY=OFF, FUSBIDIO=OFF, FVBUSONIO=OFF
#pragma config  FPLLIDIV=DIV_1, FPLLMUL=MUL_20, UPLLIDIV=DIV_1, UPLLEN=OFF
#pragma	config	FPLLODIV=DIV_2, FNOSC=FRCPLL, FSOSCEN=OFF, IESO=OFF
#pragma	config	POSCMOD=XT, OSCIOFNC=OFF, FPBDIV=DIV_1, FCKSM=CSECMD
#pragma	config	WDTPS=PS16384, WINDIS=OFF, FWDTEN=OFF, FWDTWINSZ=WINSZ_50
#pragma	config	DEBUG=OFF, JTAGEN=OFF, ICESEL=ICS_PGx2, PWP=OFF
#pragma	config	BWP=OFF, CP=OFF


/*jp.pa-i/html
<p><a href="https://github.com/paijp/diagram-in-comment">How to generate this?</a></p>
*/
/* generated HTML: https://paijp.github.io/smallest-touchpanel-ui/pic32mx/lcdtp.html */

/*jp.pa-i.cir/map32mx2-28
LSS	RPB3
LRS_T2P	RPB4
P9__SCL	RPA4
P2L_P2T	RPB5	SDO1

P19__TSS_SDA	RPB7
P7__P2B1	RPB15	UTX1
P8__B2P1	RPB13	URX1
P1__B2P2	RPB8	URX2
P10__P2B2	RPB9	UTX2

LCK_TCK	RPB14	SCK1

PGD	RPB10	PGED2	UTX2
PGC	PGEC2
fix	CLKI	CLKO	VCAP
VBUS	RB6
VUSB3V3	RB12

P2	RPA0
P3	RPA1
P4	RPB0
P5	RPB1
P6	RPB2
*/

/*jp.pa-i/html
<hr />
*/

/*jp.pa-i.cir/cir dip28 PIC32MX270F256B
22(442{r10k}2[[3V3])2[MCLR]2{c104}2[[G]
22[P2]
22[P3]
22[P4]
22[P5]
22[P6]
22[LSS]2{d}2(2[RST_LED])442{d}2[RYLED]
22[[G]
22[OSC1]
22[OSC2]
22[LRS_T2P]
22[P9_SCL]
22[[3V3]2{c106}2[[G]
22[P2L_P2T]
8
88[P19__TSS_SDA]8(448{d}8[RST_LED])8{r10k}8[[3V3]
88[P1__B2P2]
88[P10__P2B2]
888[[G]
88{c106}8[[G]
88[PGD]
88[PGC]
88[[3V3]
88[B2P]8[P8__B2P1]
88[LCK_TCK]
88[P2B]8[P7__P2B1]
88[[G]
88[[3V3]8{c104}8[[G]
*/

/*jp.pa-i.cir/cir sip14 MSP2807
22[[3V3]
22[[G]
22[LSS]
22[RST_LED]
22[LRS_T2P]
22[P2L_P2T]
22[LCK_TCK]
22[RST_LED]
2
22[LCK_TCK]
22[P19__TSS_SDA]
22[P2L_P2T]
22[LRS_T2P]
2
*/

/*jp.pa-i.cir/cir sip5 ICSP
22[MCLR]
22[[3V3]
22[[G]
22[PGD]
22[PGC]
*/

/*jp.pa-i.cir/cir dip20 CN2x10
22[P1__B2P2]
22[P2]
22[P3]
22[P4]
22[P5]
22[P6]
22[P7__P2B1]
22[P8__B2P1]
22[P9_SCL]
22[P10__P2B2]
88[(BAT)]
88[P19__TSS_SDA]
88[AD2]
88[AD1]
88[[3V3]
88[(5V)]
88[(5V)]
88[[G]
88[[G]
88[DA1]
*/

/*jp.pa-i/html
<hr />
*/

/*jp.pa-i.cir/cir dip14 MCP3424	# i2c:0x69
22[AD2]
22[[G]
22[AD1]
22[[G]
22[[G]
22[[3V3]2{c104}2[[G]
22[P19__TSS_SDA]
88[P9_SCL]
88[[G]
8
8
8
8
8
*/

/*jp.pa-i.cir/cir dip14 MCP3424	# i2c:0x68
22[AD1]
22[AD2]
22[AD2]
22[[G]
22[[G]
22[[3V3]2{c104}2[[G]
22[P19__TSS_SDA]
88[P9_SCL]
8
8
8
8
8
8
*/

/*jp.pa-i.cir/cir dip6 MCP4725	# i2c:0x60
22[DA1]
22[[G]
22[[3V3]2{c104}2[[G]
88[P19__TSS_SDA]
88[P9_SCL]
88[[G]
*/


#define	PORT_A0	PORTAbits.RA0
#define	PORT_A1	PORTAbits.RA1

#define	PORT_A3	PORTBbits.RB0
#define	PORT_A4	PORTBbits.RB1
#define	PORT_A5	PORTBbits.RB2

#define	LAT_LSS	LATBbits.LATB3
#define	LAT_LRS	LATBbits.LATB4
#define	PORT_T2P	PORTBbits.RB4
#define	TRIS_LRS_T2P	TRISBbits.TRISB4
#define	PORT_A8_SCL	PORTAbits.RA4
#define	LAT_P2L_P2T	LATBbits.LATB5

#define	LAT_TSS_SDA	LATBbits.LATB7
#define	PORT_SDA	PORTBbits.RB7
#define	PORT_A13_B2P	PORTBbits.RB8
#define	PORT_A9_P2B	PORTBbits.RB9

#define	PORT_A7	PORTBbits.RB13
#define	LAT_LCK_TCK	LATBbits.LATB14
#define	PORT_A6	PORTBbits.RB15


UW	lcdtp_flip = 0;
void	(*lcdtp_polltask)() = NULL;

const	struct	lcdtp_font_struct	lcdtp_font12h = {{NULL}, 
	{8, 12, 0, 11, 0x00, 0x60, 7, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x20, 
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 
	0x20, 0x01, 0x10, 0x01, 0xb0, 0x91, 0x20, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x30, 
	0x00, 0x01, 0x21, 0x27, 0xf2, 0x22, 0x27, 0xf2, 
	0x42, 0x42, 0x40, 0x04, 0x80, 0x00, 0x01, 0x07, 
	0xe9, 0x09, 0x07, 0xc1, 0x21, 0x2f, 0xc1, 0x00, 
	0x09, 0x40, 0x00, 0x1c, 0x14, 0x5c, 0x81, 0x02, 
	0x04, 0x09, 0xd1, 0x41, 0xc0, 0x13, 0x00, 0x00, 
	0x1c, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0xa1, 
	0x1e, 0x80, 0x27, 0x00, 0x18, 0x08, 0x10, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 
	0x00, 0x08, 0x10, 0x10, 0x20, 0x20, 0x20, 0x20, 
	0x10, 0x10, 0x08, 0x00, 0xa4, 0x00, 0x40, 0x20, 
	0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x20, 0x40, 
	0x01, 0x50, 0x00, 0x00, 0x00, 0x41, 0x50, 0xe0, 
	0x40, 0xe1, 0x50, 0x40, 0x00, 0x02, 0xb0, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x83, 0xe0, 0x80, 0x80, 
	0x00, 0x00, 0x05, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x02, 0x0b, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0c, 
	0x00, 0x2f, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 
	0x08, 0x10, 0x20, 0x40, 0x00, 0x00, 0x60, 0x00, 
	0x7c, 0x82, 0x86, 0x8a, 0x92, 0xa2, 0xc2, 0x82, 
	0x82, 0x7c, 0x00, 0xc4, 0x00, 0x20, 0x60, 0x20, 
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x01, 
	0x90, 0x01, 0xf2, 0x0a, 0x08, 0x08, 0x10, 0x20, 
	0x40, 0x81, 0x03, 0xf8, 0x03, 0x30, 0x03, 0xe4, 
	0x10, 0x10, 0x10, 0xe0, 0x10, 0x10, 0x14, 0x13, 
	0xe0, 0x06, 0x80, 0x00, 0x40, 0xc1, 0x42, 0x44, 
	0x48, 0x4f, 0xe0, 0x40, 0x40, 0x40, 0x0d, 0x40, 
	0x1f, 0xd0, 0x10, 0x10, 0x1f, 0x90, 0x40, 0x40, 
	0x50, 0x4f, 0x80, 0x1b, 0x00, 0x1f, 0x20, 0xa0, 
	0x20, 0x3f, 0x20, 0xa0, 0xa0, 0xa0, 0x9f, 0x00, 
	0x37, 0x00, 0x7f, 0x41, 0x41, 0x42, 0x02, 0x04, 
	0x04, 0x08, 0x08, 0x08, 0x00, 0x70, 0x00, 0x7c, 
	0x82, 0x82, 0x82, 0x7c, 0x82, 0x82, 0x82, 0x82, 
	0x7c, 0x00, 0xe4, 0x00, 0xf9, 0x05, 0x05, 0x05, 
	0x04, 0xfc, 0x04, 0x04, 0x04, 0xf8, 0x01, 0xd0, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0x00, 0x00, 
	0xc0, 0xc0, 0x00, 0x03, 0xb0, 0x00, 0x00, 0x00, 
	0x01, 0x81, 0x80, 0x00, 0x01, 0x80, 0x81, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x40, 0x81, 0x02, 0x04, 
	0x02, 0x01, 0x00, 0x80, 0x40, 0x0f, 0x40, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x0f, 0x80, 
	0x00, 0x00, 0x1f, 0x00, 0x00, 0x10, 0x08, 0x04, 
	0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00, 0x3f, 
	0x00, 0x00, 0x1c, 0x22, 0x02, 0x02, 0x04, 0x08, 
	0x08, 0x00, 0x08, 0x00, 0x80, 0x00, 0x00, 0x7c, 
	0x82, 0x9a, 0xaa, 0xaa, 0xaa, 0x94, 0x80, 0x7c, 
	0x01, 0x04, 0x00, 0x20, 0x20, 0x50, 0x50, 0x88, 
	0xf8, 0x89, 0x05, 0x05, 0x04, 0x02, 0x10, 0x03, 
	0xf1, 0x09, 0x09, 0x09, 0xf1, 0x09, 0x09, 0x09, 
	0x0b, 0xf0, 0x04, 0x30, 0x03, 0xe4, 0x14, 0x04, 
	0x04, 0x04, 0x04, 0x04, 0x04, 0x13, 0xe0, 0x08, 
	0x80, 0x0f, 0x84, 0x44, 0x24, 0x24, 0x24, 0x24, 
	0x24, 0x24, 0x4f, 0x80, 0x11, 0x40, 0x1f, 0xc8, 
	0x08, 0x08, 0x0f, 0x88, 0x08, 0x08, 0x08, 0x1f, 
	0xc0, 0x23, 0x00, 0x3f, 0x90, 0x10, 0x10, 0x1f, 
	0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x47, 0x00, 
	0x3e, 0x41, 0x40, 0x40, 0x4f, 0x41, 0x41, 0x41, 
	0x43, 0x3d, 0x00, 0x90, 0x00, 0x82, 0x82, 0x82, 
	0x82, 0xfe, 0x82, 0x82, 0x82, 0x82, 0x82, 0x01, 
	0x24, 0x00, 0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 
	0x20, 0x20, 0x20, 0x70, 0x02, 0x50, 0x00, 0x38, 
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x12, 0x11, 
	0xe0, 0x04, 0xb0, 0x04, 0x24, 0x44, 0x85, 0x06, 
	0x05, 0x04, 0x84, 0x44, 0x24, 0x10, 0x09, 0x80, 
	0x0e, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
	0x04, 0x2f, 0xe0, 0x13, 0x40, 0x10, 0x58, 0xd5, 
	0x52, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x40, 
	0x27, 0x00, 0x20, 0xb0, 0xa8, 0xa4, 0xa2, 0xa1, 
	0xa0, 0xa0, 0xa0, 0xa0, 0x80, 0x4f, 0x00, 0x3e, 
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
	0x3e, 0x00, 0xa0, 0x00, 0xfc, 0x82, 0x82, 0x82, 
	0xfc, 0x80, 0x80, 0x80, 0x80, 0x80, 0x01, 0x44, 
	0x00, 0xf9, 0x05, 0x05, 0x05, 0x05, 0x05, 0x25, 
	0x15, 0x0c, 0xf8, 0x02, 0x90, 0x03, 0xf2, 0x0a, 
	0x0a, 0x0a, 0x0b, 0xf2, 0x42, 0x22, 0x12, 0x08, 
	0x05, 0x30, 0x03, 0xe4, 0x14, 0x04, 0x03, 0x80, 
	0x60, 0x10, 0x14, 0x13, 0xe0, 0x0a, 0x80, 0x0f, 
	0xe1, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x00, 0x15, 0x40, 0x10, 0x50, 0x50, 0x50, 
	0x50, 0x50, 0x50, 0x50, 0x50, 0x4f, 0x80, 0x2b, 
	0x00, 0x20, 0xa0, 0x91, 0x11, 0x11, 0x0a, 0x0a, 
	0x0a, 0x04, 0x04, 0x00, 0x57, 0x00, 0x41, 0x41, 
	0x49, 0x49, 0x55, 0x55, 0x55, 0x22, 0x22, 0x22, 
	0x00, 0xb0, 0x00, 0x82, 0x82, 0x44, 0x28, 0x10, 
	0x28, 0x44, 0x82, 0x82, 0x82, 0x01, 0x64, 0x01, 
	0x05, 0x04, 0x88, 0x50, 0x20, 0x20, 0x20, 0x20, 
	0x20, 0x20, 0x02, 0xd0, 0x03, 0xf8, 0x08, 0x10, 
	0x20, 0x40, 0x40, 0x81, 0x02, 0x03, 0xf8, 0x05, 
	0xb0, 0x01, 0xe1, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0xe0, 0x0b, 0x80, 0x00, 0x00, 
	0x08, 0x04, 0x02, 0x01, 0x00, 0x80, 0x40, 0x20, 
	0x00, 0x17, 0x40, 0x0f, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x0f, 0x00, 0x2f, 0x00, 
	0x04, 0x0a, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 
	0xc0, 0x00, 0x20, 0x10, 0x08, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x84, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x78, 0x84, 0x3c, 0x44, 0x84, 
	0x7c, 0x03, 0x10, 0x03, 0x01, 0x01, 0x01, 0x01, 
	0xf1, 0x09, 0x09, 0x09, 0x0b, 0xf0, 0x06, 0x30, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xe2, 0x12, 0x02, 
	0x02, 0x11, 0xe0, 0x0c, 0x80, 0x00, 0x60, 0x20, 
	0x20, 0x23, 0xe4, 0x24, 0x24, 0x24, 0x23, 0xe0, 
	0x19, 0x40, 0x00, 0x00, 0x00, 0x00, 0x07, 0x88, 
	0x4f, 0xc8, 0x08, 0x47, 0x80, 0x33, 0x00, 0x03, 
	0x04, 0x84, 0x04, 0x0f, 0x04, 0x04, 0x04, 0x04, 
	0x04, 0x00, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1f, 0x21, 0x21, 0x1f, 0x01, 0x21, 0x1e, 0xd0, 
	0x00, 0x40, 0x40, 0x40, 0x40, 0x7c, 0x42, 0x42, 
	0x42, 0x42, 0x42, 0x01, 0xa4, 0x00, 0x00, 0x00, 
	0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x78, 
	0x03, 0x50, 0x00, 0x00, 0x00, 0x10, 0x00, 0x30, 
	0x10, 0x10, 0x10, 0x10, 0x90, 0x66, 0xb0, 0x02, 
	0x02, 0x02, 0x02, 0x02, 0x22, 0x42, 0x83, 0x42, 
	0x22, 0x10, 0x0d, 0x80, 0x01, 0x80, 0x80, 0x80, 
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x40, 0x1b, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x92, 0x52, 
	0x52, 0x52, 0x52, 0x40, 0x37, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0x10, 0x90, 0x90, 0x90, 0x90, 
	0x80, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 
	0x21, 0x21, 0x21, 0x21, 0x1e, 0x00, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7c, 0x42, 0x42, 0x42, 
	0x7c, 0x40, 0x41, 0xc4, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7c, 0x84, 0x84, 0x84, 0x7c, 0x04, 0x07, 
	0x90, 0x00, 0x00, 0x00, 0x00, 0x01, 0x71, 0x89, 
	0x01, 0x01, 0x01, 0x00, 0x07, 0x30, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf2, 0x01, 0x80, 0x60, 0x13, 
	0xe0, 0x0e, 0x80, 0x00, 0x00, 0x01, 0x01, 0x03, 
	0xc1, 0x01, 0x01, 0x01, 0x00, 0xc0, 0x1d, 0x40, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x48, 0x48, 0x48, 
	0x48, 0x47, 0xc0, 0x3b, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x20, 0x91, 0x11, 0x0a, 0x0a, 0x04, 0x00, 
	0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x49, 
	0x55, 0x55, 0x36, 0x22, 0x00, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 
	0x42, 0x01, 0xe4, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x84, 0x88, 0x50, 0x50, 0x20, 0x40, 0x83, 0xd0, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x10, 0x20, 
	0x40, 0x81, 0xf8, 0x07, 0xb0, 0x00, 0x60, 0x80, 
	0x80, 0x81, 0x00, 0x80, 0x80, 0x80, 0x80, 0x60, 
	0x0f, 0x80, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x00, 0x1f, 0x40, 0x0c, 
	0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 
	0x0c, 0x00, 0x3f, 0x00, 0x0c, 0x93, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x1c, 0x1c, 
	0x00, 0x00, 0x00, 0x00, 0x00}
};


#if 0
static	void	wait025us(void)
{
	long	l;
	
	for (l=1; l>0; l--)
		asm("nop");
}


static	void	wait05us(void)
{
	long	l;
	
	for (l=7; l>0; l--)
		asm("nop");
}
#endif


static	void	wait1us(void)
{
	long	l;
	
	for (l=15; l>0; l--)
		asm("nop");
}


#if 0
static	void	wait10us(void)
{
	long	l;
	
	for (l=150; l>0; l--)
		asm("nop");
}
#endif


static	void	wait100us(void)
{
	long	l;
	
	if ((lcdtp_polltask))
		lcdtp_polltask();
	
	for (l=1500; l>0; l--)
		asm("nop");
}


void	dly_tsk(W ms)
{
	ms *= 10;
	while (ms-- > 0)
		wait100us();
}


static	void	lcd_wait()
{
	while (SPI1STATbits.SRMT == 0)
		if ((lcdtp_polltask))
			lcdtp_polltask();
}


static	void	lcd_write(UB v)
{
	
	if ((lcdtp_polltask)) {
		static	W	count = 0;
		
		if (count-- <= 0) {
			count = 200;
			lcdtp_polltask();
		}
	}
	
	while ((SPI1STATbits.SPITBF))
		if ((lcdtp_polltask))
			lcdtp_polltask();
	SPI1BUF = v;
	return;
}


static	W	gettpinner(UW cmd)
{
	W	i, ret;
	
	if ((lcdtp_polltask))
		lcdtp_polltask();
	
	LAT_LSS = 1;
	
	RPB5R = 0;		/* port */
	SPI1CON = 0;
	LAT_LCK_TCK = 1;
	
	TRIS_LRS_T2P = 1;		/* input */
	LAT_TSS_SDA = 0;
	
	for (i=0; i<8; i++) {
		wait1us();
		LAT_P2L_P2T = (cmd & (0x80 >> i))? 1 : 0;
		wait1us();
		LAT_LCK_TCK = 0;
		wait1us();
		LAT_LCK_TCK = 1;
	}
	
	wait1us();
	wait1us();
	wait1us();
	wait1us();
	wait1us();
	LAT_P2L_P2T = 0;
	
	ret = 0;
	for (i=0; i<16; i++) {
		wait1us();
		LAT_LCK_TCK = 0;
		wait1us();
		LAT_LCK_TCK = 1;
		
		if ((PORT_T2P))
			ret |= (0x8000 >> i);
	}
	
	LAT_TSS_SDA = 1;
	TRIS_LRS_T2P = 0;		/* output */
	
	RPB5R = 3;		/* SDO1 */
	SPI1CON = 0;
	SPI1CONbits.ENHBUF = 1;
	SPI1CONbits.CKE = 1;
	SPI1CONbits.MSTEN = 1;
	SPI1CONbits.DISSDI = 1;
	SPI1CONbits.STXISEL = 3;
	SPI1STAT = 0;
	SPI1BRG = 0;
	SPI1CONbits.ON = 1;
	
	return ret;
}


static	W	gettpavg(UW cmd)
{
#define	BOXES	0x40
	static	W	count[BOXES + 1], sum[BOXES + 1];
	W	i, v;
	
	for (i=0; i<=BOXES; i++)
		count[i] = sum[i] = 0;
	
	for (;;) {
		v = gettpinner(cmd);
		i = (v >> 10) & (BOXES - 1);
		count[i]++;
		sum[i] += v;
		count[i + 1]++;
		sum[i + 1] += v;
		
		if (count[i] >= 8)
			return (sum[i] + 4) >> 3;
		if (count[i + 1] >= 8)
			return (sum[i + 1] + 4) >> 3;
	}
}


void	gfil_rec(W l, W t, W r, W b, UW color)
{
	W	i;
	
	if ((lcdtp_polltask))
		lcdtp_polltask();
	
	if (l < 0)
		l = 0;
	if (r > LCD_W)
		r = LCD_W;
	if (t < 0)
		t = 0;
	if (b >= LCD_H)
		b = LCD_H;
	if (l >= r)
		return;
	if (t >= b)
		return;
	
	r--;
	b--;
	LAT_LSS = 0;
	LAT_LRS = 0;
	lcd_write(0x2a);
	lcd_wait();
	
	LAT_LRS = 1;
	lcd_write(l >> 8);		/* left */
	lcd_write(l & 0xff);
	lcd_write(r >> 8);		/* right */
	lcd_write(r & 0xff);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0x2b);
	lcd_wait();
	
	LAT_LRS = 1;
	lcd_write(t >> 8);		/* top */
	lcd_write(t & 0xff);
	lcd_write(b >> 8);		/* bottom */
	lcd_write(b & 0xff);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0x2c);
	lcd_wait();
	
	LAT_LRS = 1;
	
	i = (r - l + 1) * (b - t + 1);
	while (i-- > 0) {
		lcd_write(color >> 8);
		lcd_write(color & 0xff);
	}
	lcd_wait();
	LAT_LSS = 1;
}


static	const	UB	*bitbuf = NULL;
static	const	UB	*bitp = NULL;
static	W	bitpos = 0;


static	void	setbitbuf(const unsigned char *p, W pos)
{
	if ((p))
		bitbuf = p;
	bitpos = pos;
	bitp = bitbuf + (pos >> 3);
}


static	W	getbit(W size)
{
	W	ret;
	
	ret = 0;
	while (size-- > 0) {
		ret <<= 1;
		if (((*bitp << (bitpos & 7)) & 0x80))
			ret |= 1;
		if ((++bitpos & 7) == 0)
			bitp++;
	}
	return ret;
}


static	W	findcode(W code)
{
	W	pos, mask, size;
	W	bitsize;
	W	codebits;
	W	c;
	
	setbitbuf(NULL, 0);
	bitsize = getbit(8);		/* width */
	bitsize *= getbit(8);		/* height */
	setbitbuf(NULL, 8 * 4);
	size = getbit(16);
	codebits = getbit(8);
	bitsize += codebits;		/* code */
	
	c = getbit(codebits);			/* first code */
	if (code < c)
		return 0;		/* out of range */
	if (code == c)
		return 1;		/* found */
	
	setbitbuf(NULL, 8 * 4 + 16 + 8 + bitsize * (size - 1));
	c = getbit(codebits);			/* last code */
	if (code > c)
		return 0;		/* out of range */
	if (code == c)
		return 1;		/* found */
	
	pos = 0;
	mask = 0x10000;
	while ((mask)) {
		mask >>= 1;
		if ((pos | mask) >= size)
			continue;
		setbitbuf(NULL, 8 * 4 + 16 + 8 + bitsize * (pos | mask));
		c = getbit(codebits);	
		if (code == c)
			return 1;		/* found */
		if (code > c)
			pos |= mask;
	}
	return 0;		/* not found */
}


void	gdra_stp(W x, W y, UW color, UW bgcolor, const struct lcdtp_font_struct *font, const UB *s)
{
	if ((lcdtp_polltask))
		lcdtp_polltask();
	
	if (s == NULL)
		return;
	
	if (font == NULL)
		font = &lcdtp_font12h;
	
	for (;;) {
		const	struct	lcdtp_font_struct	*f;
		W	c;
		
		if ((c = *(s++)) < 0x80) {
			if (c == 0)
				break;
		} else if ((c & 0xe0) == 0xc0)
			c = ((c & 0x1f) << 6) | (*(s++) & 0x3f);
		else if ((c & 0xf0) == 0xe0) {
			c = (c & 0xf) << 12;
			c |= (*(s++) & 0x3f) << 6;
			c |= *(s++) & 0x3f;
		} else if ((c & 0xf8) == 0xf0) {
			c = (c & 7) << 18;
			c |= (*(s++) & 0x3f) << 12;
			c |= (*(s++) & 0x3f) << 6;
			c |= *(s++) & 0x3f;
		} else if ((c & 0xfc) == 0xf8) {
			c = (c & 3) << 24;
			c |= (*(s++) & 0x3f) << 18;
			c |= (*(s++) & 0x3f) << 12;
			c |= (*(s++) & 0x3f) << 6;
			c |= *(s++) & 0x3f;
		} else if ((c & 0xfe) == 0xfc) {
			c = (c & 1) << 30;
			c |= (*(s++) & 0x3f) << 24;
			c |= (*(s++) & 0x3f) << 18;
			c |= (*(s++) & 0x3f) << 12;
			c |= (*(s++) & 0x3f) << 6;
			c |= *(s++) & 0x3f;
		} else
			continue;
		
		f = font;
		while ((f)) {
			W	fw, fh, offx, offy;
			
			setbitbuf(f->font, 0);
			fw = getbit(8);
			fh = getbit(8);
			offx = getbit(8);
			offy = getbit(8);
			if (findcode(c) == 0) {
				f = f->attr.fallback;
				continue;
			}
			do {
				W	x0, y0, i;
				
				x0 = x - offx;
				y0 = y - offy;
				if (x0 < 0)
					break;
				if (x0 + fw >= LCD_W)
					return;
				if (y0 < 0)
					break;
				if (y0 + fh >= LCD_H)
					break;
				
				LAT_LSS = 0;
				LAT_LRS = 0;
				lcd_write(0x2a);
				lcd_wait();
				
				LAT_LRS = 1;
				lcd_write(x0 >> 8);		/* left */
				lcd_write(x0 & 0xff);
				lcd_write((x0 + fw - 1) >> 8);		/* right */
				lcd_write((x0 + fw - 1) & 0xff);
				lcd_wait();
				
				LAT_LRS = 0;
				lcd_write(0x2b);
				lcd_wait();
				
				LAT_LRS = 1;
				lcd_write(y0 >> 8);		/* top */
				lcd_write(y0 & 0xff);
				lcd_write((y0 + fh - 1) >> 8);		/* bottom */
				lcd_write((y0 + fh - 1) & 0xff);
				lcd_wait();
				
				LAT_LRS = 0;
				lcd_write(0x2c);
				lcd_wait();
				
				LAT_LRS = 1;
				
				i = fw * fh;
				while (i-- > 0)
					if ((getbit(1))) {
						lcd_write(color >> 8);
						lcd_write(color & 0xff);
					} else {
						lcd_write(bgcolor >> 8);
						lcd_write(bgcolor & 0xff);
					}
				
				lcd_wait();
				LAT_LSS = 1;
			} while (0);
			x += fw;
			break;
		}
	}
}


W	gget_stw(const struct lcdtp_font_struct *font, const UB *s)
{
	W	ret;
	
	if ((lcdtp_polltask))
		lcdtp_polltask();
	
	if (s == NULL)
		return 0;
	
	if (font == NULL)
		font = &lcdtp_font12h;
	
	ret = 0;
	for (;;) {
		const	struct	lcdtp_font_struct	*f;
		W	c;
		
		if ((c = *(s++)) < 0x80) {
			if (c == 0)
				break;
		} else if ((c & 0xe0) == 0xc0)
			c = ((c & 0x1f) << 6) | (*(s++) & 0x3f);
		else if ((c & 0xf0) == 0xe0) {
			c = (c & 0xf) << 12;
			c |= (*(s++) & 0x3f) << 6;
			c |= *(s++) & 0x3f;
		} else if ((c & 0xf8) == 0xf0) {
			c = (c & 7) << 18;
			c |= (*(s++) & 0x3f) << 12;
			c |= (*(s++) & 0x3f) << 6;
			c |= *(s++) & 0x3f;
		} else if ((c & 0xfc) == 0xf8) {
			c = (c & 3) << 24;
			c |= (*(s++) & 0x3f) << 18;
			c |= (*(s++) & 0x3f) << 12;
			c |= (*(s++) & 0x3f) << 6;
			c |= *(s++) & 0x3f;
		} else if ((c & 0xfe) == 0xfc) {
			c = (c & 1) << 30;
			c |= (*(s++) & 0x3f) << 24;
			c |= (*(s++) & 0x3f) << 18;
			c |= (*(s++) & 0x3f) << 12;
			c |= (*(s++) & 0x3f) << 6;
			c |= *(s++) & 0x3f;
		} else
			continue;
		
		f = font;
		while ((f)) {
			W	fw;
			
			setbitbuf(f->font, 0);
			fw = getbit(8);
			if (findcode(c) == 0) {
				f = f->attr.fallback;
				continue;
			}
			ret += fw;
			break;
		}
	}
	
	return ret;
}


void	init_lcdtp(void)
{
	CNPUA = 0xffff;
	CNPUB = 0xffff;
	
	CNPDB = 0;
	CNPDB = 0;
	
	TRISA = 0x0000;		/* -------- ---O--OO */
	TRISB = 0x0000;		/* OOO---OO O-OOOOOO */
	
	ANSELA = 0;
	ANSELB = 0;
	
	PORTA = 0xffff;
	PORTB = 0xffff;
	
	SYSKEY = 0;
	SYSKEY = 0xaa996655;
	SYSKEY = 0x556699aa;
	SYSKEY = 0;
	
	gettpinner(0);		/* setup SPI1 */
	
	/* ref http://www.lcdwiki.com/res/Program/Common_SPI/2.8inch/SPI_ILI9341_MSP2807_V1.1/2.8inch_SPI_Module_ILI9341_MSP2807_V1.1.zip */
	
	LAT_LSS = 0;
	dly_tsk(1);
	LAT_LRS = 0;
	lcd_write(0xcb);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x39);
	lcd_write(0x2c);
	lcd_write(0x00);
	lcd_write(0x34);
	lcd_write(0x02);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xcf);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x00);
	lcd_write(0xc1);
	lcd_write(0x30);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xe8);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x85);
	lcd_write(0x00);
	lcd_write(0x78);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xea);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x00);
	lcd_write(0x00);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xed);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x64);
	lcd_write(0x03);
	lcd_write(0x12);
	lcd_write(0x81);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xf7);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x20);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xc0);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x23);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xc1);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x10);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xc5);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x3e);
	lcd_write(0x28);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xc7);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x86);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0x36);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x48);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0x3a);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x55);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xb1);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x00);
	lcd_write(0x18);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0xb6);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0x08);
	lcd_write(0x82);
	lcd_write(0x27);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0x11);
	lcd_wait();
	
	dly_tsk(200);
	
	lcd_write(0x29);
	lcd_write(0x2c);
	lcd_wait();
	LAT_LRS = 1;
	
	LAT_LSS = 1;
	
	dly_tsk(200);
	
	LAT_LSS = 0;
	LAT_LRS = 0;
	lcd_write(0x2a);
	lcd_wait();
	
	LAT_LRS = 1;
	lcd_write(0);		/* left */
	lcd_write(0);
	lcd_write(0);		/* right */
	lcd_write(240);
	lcd_wait();
	
	LAT_LRS = 0;
	lcd_write(0x2b);
	lcd_wait();
	LAT_LRS = 1;
	lcd_write(0);		/* top */
	lcd_write(0);
	lcd_write(1);		/* bottom */
	lcd_write(0);
	lcd_wait();
	LAT_LRS = 0;
	lcd_write(0x2c);
	lcd_wait();
	LAT_LRS = 1;
	
	gettp();
}


UW	gettp()
{
	static	W	pressed = 1;
	W	x, y, type;
	UW	z0, z1;
	
	z0 = gettpinner(0xb0);
	z1 = gettpinner(0xc0);
	if (z0 < (8 << 7)) {
		if (z0 < (4 << 7))
			pressed = 0;
		return TPLIB_CMD_NULL;
	}
	if (z1 > (0xf8 << 7)) {
		if (z1 > (0xfc << 7))
			pressed = 0;
		return TPLIB_CMD_NULL;
	}
	x = gettpinner(0xd0);
	y = gettpinner(0x90);
	z0 = gettpinner(0xb0);
	z1 = gettpinner(0xc0);
	if (z0 < (8 << 7)) {
		if (z0 < (4 << 7))
			pressed = 0;
		return TPLIB_CMD_NULL;
	}
	if (z1 > (0xf8 << 7)) {
		if (z1 > (0xfc << 7))
			pressed = 0;
		return TPLIB_CMD_NULL;
	}
	
	x = (0x7800 - x) * LCD_W / 0x7000;
	y = (y - 0x800) * LCD_H / 0x7000;
	
	if (x < 0)
		x = 0;
	if (x >= LCD_W)
		x = LCD_W - 1;
	if (y < 0)
		y = 0;
	if (y >= LCD_H)
		y = LCD_H - 1;
	
	if ((lcdtp_flip & LCDTP_FLIP_X))
		x = LCD_W - 1 - x;
	if ((lcdtp_flip & LCDTP_FLIP_Y))
		y = LCD_H - 1 - y;
	
	type = TPLIB_CMD_PRESS;
	if ((pressed))
		type = TPLIB_CMD_PRESSING;
	pressed = 1;
	
	return type | (x << 12) | y;
}


void	lcdtp_sendlogc(W c)
{
	static	W	first = 1;
	
	if ((first)) {
		first = 0;
		
		RPB10R = 2;		/* UTX2 */
		U2MODE = 0;
		U2BRG = 86;		/* 115.4kbps */
		U2MODE = 0x8008;	/* enable N81 4(U2BRG + 1) */
		U2STA = 0x1400;
	}
	for (;;) {
		if (U2STAbits.UTXBF == 0) {
			U2TXREG = c;
			return;
		}
		if ((lcdtp_polltask))
			lcdtp_polltask();
	}
}


void	lcdtp_sendlogs(const char *s)
{
	W	c;
	
	while ((c = *(s++)))
		lcdtp_sendlogc(c);
}


void	lcdtp_sendlogdec(W v)
{
	if ((v < 0)) {
		v = -v;
		lcdtp_sendlogc('-');
	}
	if (v >= 10)
		lcdtp_sendlogdec(v / 10);
	lcdtp_sendlogc('0' + (v % 10));
}


void	lcdtp_sendlogun(UW v)
{
	static	const	char *bin2hex = "0123456789abcdef";
	
	lcdtp_sendlogc(bin2hex[v & 0xf]);
}


void	lcdtp_sendlogub(UW v)
{
	lcdtp_sendlogun(v >> 4);
	lcdtp_sendlogun(v);
}


void	lcdtp_sendloguh(UW v)
{
	lcdtp_sendlogun(v >> 12);
	lcdtp_sendlogun(v >> 8);
	lcdtp_sendlogun(v >> 4);
	lcdtp_sendlogun(v);
}


void	lcdtp_sendloguw(UW v)
{
	lcdtp_sendlogun(v >> 28);
	lcdtp_sendlogun(v >> 24);
	lcdtp_sendlogun(v >> 20);
	lcdtp_sendlogun(v >> 16);
	lcdtp_sendlogun(v >> 12);
	lcdtp_sendlogun(v >> 8);
	lcdtp_sendlogun(v >> 4);
	lcdtp_sendlogun(v);
}


